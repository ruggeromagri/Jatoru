# Script connecting substitions in dynamic context

## Thomas Bouillet, Ruggero Magrì & Jan Šindler

### 7th December 2019, Den Haag

#### Introduction

In order to explain the three openType features, we chose to design two characters and illustrate how features work between them. Letters *g and *r were designed in two masters (light and bold), with swashes, script connections and alternative shapes for bolder instances. A python script was written to generate a designspace that contained the two sources, instances and weight substitution rules.
Finally, we export a functioning variable font using fontmake from Google that contains names of instances, swash feature, script connecting feature. We also appreciate dynamic source data. We used fontmake CLI to export variable font, we are aware that going to CLI is extra step. This is something that we would also like to integrate if continuing working on this font. We decided to work with UFO files in order to achieve transparency and smoother team work via GitHub and FontTool’s (Erik’s) designspace library helped use to design more dynamic and better infrastructure. 


#### 1. pattern replace
 

Through substitution, opentype features allow you to replace selected glyphs with other ones.
There are different kind of substitutions. The replacement can be executed for one with one, many with one, one with many, and one from many
In the pattern replacement, we want to replace a glyph when is part of a specific sequence. For example: replace *r with *r.swash, when *r is followed by *space.
Groups of letters can be also defined, in such way @lowercase. This would ideally contain all lowercase letters. Such group could be later used when designing substitution patterns.
If we were extending the characters we would define OTF groups for this replacement, meaning that ’r’ would probably be in group with ’nmup’. So ‘g’ would connect to each child of this group the same way with no many extra code. 
In order to do that, inside the feature we need to call the substitution with the prefix “sub”, specify all the components of the pattern (@lowercase r space), use “by” to announce the replacement we are going to do, and than write the name  of the glyph we want to use (r.swash).
To specify which letter we want to be replaced inside the sequence with use the ‘ right after it.

```
sub @lowercase r’ space by r.swash;
```

The sequence of things before the glyph we want to replace is called “backtrack”, everything after is called “lookahead”. Both of them are optional: either, or neither, can appear. If a sequence is present, it can contain one or more things.



#### 2. axis conditionals

Designing design spaces means, most of the times, accept compromises between masters to make everything works smoothly and consistently. Sometimes, this compromises can be avoided by switching from one glyph to a specific alternates at a certain value inside the design space.
In order to do that, first we need to design both version of the original glyph and its alternate for each master. Then through opentype feature, we can specify the exact moment when we want to do the replacement. The name of the variable font’s feature is “rvrn” (Required Variation Alternates) inside GSUB table, where other substitutions can be found. Through the use of a “.designspace” file that is generated by a Python script we can easily manage the parameter. Within the code we are going to have a specific rule for the substitution:

<rule name=“substitution.g”>

inside the rule we first find the “condition set”, inside the one we find the axes and the value we want to apply the substitution:
```
	<conditionsets>
		<condition name=“weight” minimum=“100” maximum=“170”/>
	</conditionsets>
```
and then the actual substitution
```
	<sub name=“g” with=“g.alt”>
</rule>
```
#### 3. Connecting script

We worked with the glyphs ‘g’ and the ‘r’ as it is not really a ligature, we defined this more like a script connection. Even though it might seem that these two glyphs are connected, it is exactly the opposite. Create ligature for each combination would be very unrealistic, we suppose dividing our glyphset in multiple groups where glyphs can join can narrow this problem down. Classical substition "two glyphs substituted by one glyph" can be taken in cosinderation while designing ligatures for frequent combinations.

substitutions in our case are achieved with
```
    feature liga {
        sub g' r by g.connected;
        sub g' r.swash by g.connected;
        sub g.alt' r by g.alt.connected;
        sub g.alt' r.swash by g.alt.connected;
    } liga;
```
